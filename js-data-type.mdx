---
title: 'JS 데이터 타입'
date: '2023-06-06'
tags: ['JS', '코어 자바스크립트 1장', '데이터 타입']
---

# 데이터 타입

## 학습 목표

- 자바스크립트가 데이터를 처리하는 과정 이해한다.
- 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해한다.
- 데이터 타입과 관련된 중요한 개념 및 몇 가지 추가사항을 살펴본다.

---

## 1. 데이터 타입의 종류

Data Type

ㄴ Primitive type

ㄴ Number / String / Boolean / null / undefined / Symbol

ㄴ Reference type

ㄴ Object (Array, Function, Date, RegExp etc.)

### 1-1. 기본형(원시형)과 참조형의 차이점

- 기본형(원시형): 값이 담긴 주소값을 바로 복제 → 불변성(Immutability)
- 참조형: 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제 → 가변성(Mutability)

---

## 2. 데이터 타입에 관한 배경지식

### 2-1. 메모리와 데이터

<aside>
💡 **용어 정리: 비트와 바이트**
**비트(bit)**
: 0 또는 1만 표현할 수 있는 하나의 메모리 조각, 각 비트는 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있다.
**바이트(byte)**
: 8개의 비트로 이루어진 메모리 단위, 시작하는 비트의 식별자로 위치가 파악된다.

cf. 식별자(identifier): 메모리 주소값(memory address)를 일컫는다.

</aside>

### 2-2. 식별자와 변수

<aside>
💡 **용어 정리: 식별자(identifier)와 변수(variable)**
**변수**
: 변할 수 있는 데이터 (“변경 가능한 데이터가 담길 수 있는 공간 또는 그릇”)
**식별자**
: 데이터를 식별하는데 사용되는 이름, 즉 **변수명**

</aside>

---

## 3. 변수 선언과 데이터 할당

### 3-1. 변수 선언

```jsx
// ex 1-1
var a;
// 변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.
```

- 데이터 할당의 흐름
  1. 메모리에서 비어있는 공간 하나를 확보
  2. 해당 공간의 이름(식별자)을 a라고 지정
     — (변수 선언 과정)
  3. 사용자가 a에 접근시, 메모리에서 a라는 이름을 가진 주소를 검색
  4. 해당 공간에 담긴 데이터를 반환
  - 변수 영역
    | 주소 | … | 1002 | 1003 | 1004 | … |
    | --- | --- | ---- | ------- | ---- | --- |
    | 데이터 | | | 이름; a |
    | 값: | | |

### 3-2. 데이터 할당

```jsx
var a; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```

- 데이터 할당의 흐름
  1. 변수 영역에서 빈 공간(@1003)을 확보한다.
  2. 확보한 공간의 식별자를 a로 지정한다.
  3. 데이터 영역의 빈 공간(@5004)에 문자열 ‘abc’를 저장한다.
  4. 변수 영역에서 a라는 식별자를 검색한다(@1003).
  5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다
  - 변수 영역
    | 주소 | … | 1002 | 1003 | 1004 | … |
    | --------- | --- | ---- | ------- | ---- | --- |
    | 데이터 | | | 이름; a |
    | 값: @5004 | | |
  - 데이터 영역
    | 주소 | … | 5002 | 5003 | 5004 | … |
    | ------ | --- | ---- | ---- | ----- | --- |
    | 데이터 | | | | ‘abc’ | |

<aside>
💡 **JS Sense!**
Q1. 숫자형 데이터의 공간은?
A1. 64비트(8바이트)

Q2. 문자열 데이터의 공간은?
A2. 문자열은 특별히 정해진 규격이 없다. 한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 각각 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이기 때문이다.

</aside>

**NOTE** 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

- 문자열 변환에 대한 메모리 영역의 변화
  ```jsx
  a = a + 'def';
  ```
  - 데이터 할당의 흐름
    1. 변수 영역에서 이름이 a인 메모리 주소를 찾는다.
    2. 해당 변수(a)에 저장된 주소값 @5004에 저장된 데이터 영역의 값(’abc’)를 찾는다.
    3. @5004에 저장된 값과 ‘def’를 더하여 만들어진 새로운 값 ‘abcdef’를 데이터 영역의 @5002에 저장한다.
    4. 변수 영역에서 a라는 식별자를 검색한다(@1003).
    5. 앞서 저장한 문자열의 주소(@5002)를 @1003의 공간에 새롭게 대입한다.
    - 변수 영역
      | 주소 | … | 1002 | 1003 | 1004 | … |
      | --------- | --- | ---- | ------- | ---- | --- |
      | 데이터 | | | 이름; a |
      | 값: @5002 | | |
    - 데이터 영역
      | 주소 | … | 5002 | 5003 | 5004 | … |
      | ------ | --- | -------- | ---- | ----- | --- |
      | 데이터 | | ‘abcdef’ | | ‘abc’ | |

---

## 4. 기본형 데이터와 참조형 데이터

### 4-1. 불변값

- 변수와 상수를 구분 짓는 Point!
  : 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부를 통해 확인이 가능하다.

**NOTE** 숫자, 문자열, boolean, null, undefined, Symbol은 불변값이다.

- 불변값의 성질
  : 한 번 만든 값을 바꿀 수 없고, 변경은 새로운 데이터 영역에 입력된 데이터를 생성하여 새로운 주소값을 변수 영역의 데이터에 넣는 동작을 통해서만 이루어진다.

  ```jsx
  var a;
  a = 'abc'; // 변수 a에 'abc'를 할당한다.

  a = a + 'def'; // a = 'abcdef';
  // 변수 a에 'abcdef'를 새롭게 할당한다.
  ```

  | 주소      | …   | 1002 | 1003    | 1004  | 1005     | …   |
  | --------- | --- | ---- | ------- | ----- | -------- | --- |
  | 데이터    |     |      | 이름: a |
  | 값: @5004 |     |      |         |
  | 주소      | …   | 5002 | 5003    | 5004  | 5005     | …   |
  | 데이터    |     |      |         | ‘abc’ |          |     |
  | 주소      | …   | 1002 | 1003    | 1004  | 1005     | …   |
  | --------- | --- | ---- | ------- | ----- | -------- | --- |
  | 데이터    |     |      | 이름: a |
  | 값: @5005 |     |      |         |
  | 주소      | …   | 5002 | 5003    | 5004  | 5005     | …   |
  | 데이터    |     |      |         | ‘abc’ | ‘abcdef’ |     |

### 4-2. 가변값

- 참조형 데이터의 할당

  ```jsx
  var obj1 = {
    a: 1,
    b: 'bbb',
  };
  ```

  - 데이터 할당의 흐름
    1. 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 obj1로 지정한다.
    2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이루어진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위하여 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103 ~ @7104)를 @5001에 저장한다.
    3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.
    4. 데이터 영역에서 숫자 1을 검색한다. 검색 결과 없으므로 임의로 @5003에 저장하고, 이 주소를 @7103에 저장한다. 문자열 ‘bbb’ 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장한다.
  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | … |
    | --------- | ---- | ---------- | ---- | ---- | --- |
    | 데이터 | | 이름; obj1 |
    | 값: @5001 | | | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | … |
    | ------ | ------------- | ---- | ---- | ----- | --- |
    | 데이터 | @7103 ~ @7104 | | 1 | ‘bbb’ | |
  - 객체 @5001의 변수 영역
    | 주소 | 7103 | 7104 | 7105 | 7106 | … |
    | --------- | ------- | ---- | ---- | ---- | --- |
    | 데이터 | 이름: a |
    | 값: @5003 | 이름: b |
    | 값: @5004 | | | |

- 기본형(원시타입)과 참조형(참조타입)의 차이점

  → 객체의 변수(프로퍼티) 영역이 별도로 존재한다. 즉 객체가 별도로 할애한 영역은 변수 영역이다. 프로퍼티에 할당된 데이터는 데이터 영역에 저장된다(데이터 영역에 저장된 값은 불변값이다). 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 이러한 점 때문에 흔히 “참조형 데이터는 가변값이다”라고 한다.

- 참조형 데이터의 프로퍼티 재할당

  ```jsx
  var obj1 = {
    a: 1,
    b: 'bbb',
  };

  obj1.a = 2;
  ```

  - 데이터 재할당의 흐름
    1. 데이터 영역에서 숫자 2를 검색한다.
    2. 검색 결과가 없으므로 빈 공간인 @5005에 저장하고, 이 주소를 @7103에 저장한다.
  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | 1005 | … |
    | --------- | ---- | ---------- | ---- | ---- | ---- | --- |
    | 데이터 | | 이름; obj1 |
    | 값: @5001 | | | | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | … |
    | ------ | ------------- | ---- | ---- | ----- | ---- | --- |
    | 데이터 | @7103 ~ @7104 | | 1 | ‘bbb’ | 2 | |
  - 객체 @5001의 변수 영역
    | 주소 | 7103 | 7104 | 7105 | 7106 | 7107 | … |
    | --------- | ------- | ---- | ---- | ---- | ---- | --- |
    | 데이터 | 이름: a |
    | 값: @5005 | 이름: b |
    | 값: @5004 | | | | |
    변수 `obj1`이 바라보고 있는 주소는 @5001로 변하지 않았다. 즉 ‘새로운 객체’가 만들어 진 것이 아니라 기존의 객체 내부의 값만 바뀐 것이다.

- 중첩된 참조형 데이터(객체)의 프로퍼티 할당

  ```jsx
  var obj2 = {
    x: 3,
    arr: [3, 4, 5],
  };
  ```

  - 데이터 할당의 흐름
    1. 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 `obj2`라고 지정한다.
    2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려는데, 이 데이터는 여러 개의 변수와 값들을 모아 놓은 그룹(객체)이다. 이 그룹의 각 변수(프로퍼티)들을 저장하기 위하여 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103 ~ @7104)를 @5001에 저장한다.
    3. @7103에 이름 `x`를, @7104에 이름 `arr`를 지정한다.
    4. 데이터 영역에서 숫자 3을 검색한다. 검색 결과 없으므로 임의로 @5002에 저장하고, 이 주소를 @7103에 저장한다.
    5. @7104에 저장할 값은 배열로서 역시 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위하여 별도의 변수 영역을 마련하고(@8104 ~ @8106), 그 영역의 주소 정보(@8104 ~ @8106)를 @5003에 저장한 다음, @5003을 @7104에 저장한다.
    6. 배열의 요소가 총 3개이므로 3개의 변수 공간을 확보하고 각각 인덱스를 부여한다(0, 1, 2).
    7. 데이터 영역에서 숫자 3을 검색해서(@5002) 그 주소를 @8104에 저장한다.
    8. 데이터 영역에 숫자 4가 없으므로 @5004에 저장하고, 이 주소를 @8105에 저장한다.
    9. 데이터 영역에 숫자 5가 없으므로 @5005에 저장하고, 이 주소를 @8106에 저장한다.
  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | 1005 | … |
    | --------- | ---- | ---------- | ---- | ---- | ---- | --- |
    | 데이터 | | 이름; obj2 |
    | 값: @5001 | | | | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | … |
    | ------ | ------------- | ---- | ------------- | ---- | ---- | --- |
    | 데이터 | @7103 ~ @7104 | 3 | @8104 ~ @8106 | 4 | 5 | |
  - 객체 @5001의 변수 영역
    | 주소 | 7103 | 7104 | … |
    | --------- | --------- | ---- | --- |
    | 데이터 | 이름: x |
    | 값: @5002 | 이름: arr |
    | 값: @5003 | |
  - 객체 @5003의 변수 영역
    | 주소 | 8104 | 8105 | 8106 | … |
    | --------- | ------- | ---- | ---- | --- |
    | 데이터 | 이름: 0 |
    | 값: @5002 | 이름: 1 |
    | 값: @5004 | 이름: 2 |
    | 값: @5005 | |

- `obj2.arr[1]` 검색 과정

  1. `obj2` 검색 1: `obj2`라는 식별자를 가진 주소를 찾는다(@1002).
  2. `obj2` 검색 2: 값이 주소이므로 그 주소로 이동한다(@5001).
  3. `obj2` 검색 3: 값이 주소이므로 그 주소로 이동한다(@7103, @7104).
  4. `obj2.arr` 검색 1: `arr`이라는 식별자를 가진 주소를 찾는다(@7104).
  5. `obj2.arr` 검색 2: 값이 주소이므로 그 주소로 이동한다(@5003).
  6. `obj2.arr` 검색 3: 값이 주소이므로 그 주소로 이동한다(@8104 ~ @8106).
  7. `obj2.arr[1]` 검색 1: 인덱스 1에 해당하는 주소를 찾는다(@8105).
  8. `obj2.arr[1]` 검색 2: 값이 주소이므로 그 주소로 이동한다(@5004).
  9. `obj2.arr[1]` 검색 3: 값이 숫자형 데이터이므로 4를 반환한다.

  @1002 → @5001 → (@7103~@7104) → @7104 → @5003 → (@8104 ~ @8106) → @8105 → @5004 → “4” 반환

- `obj2.arr`에 문자열을 재할당하는 경우
  ```jsx
  obj2.arr = 'str';
  ```
  - 객체의 프로퍼티에게 재할당을 하는 경우의 흐름
    1. @5006에 문자열 ‘str’을 저장하고, 그 주소가 @7104에 저장한다.
    2. @5003의 참조 카운트는 @7104에 저장되어 있었지만, @7104에 @5006이 저장되는 순간 @5003의 참조 카운트는 0이 된다.
    3. 참조 카운트가 0이 된 메모리 주소 @5003은 가비지 컬렉터(Garbage Collector, GC) 대상이 된다.
    4. @5003에 담겨 있던 @8104 ~ @8106의 값들은 사라진다.
    5. 위와 마찬가지로 @8104 ~ @8106도 참조 카운트가 0이므로 GC 대상이 되어 사라지게 된다.
  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | 1005 | … |
    | --------- | ---- | ---------- | ---- | ---- | ---- | --- |
    | 데이터 | | 이름; obj2 |
    | 값: @5001 | | | | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | … |
    | ------ | ------------- | ---- | ------------- | ---- | ---- | ----- | --- |
    | 데이터 | @7103 ~ @7104 | 3 | @8104 ~ @8106 | 4 | 5 | ‘str’ | |
  - 객체 @5001의 변수 영역
    | 주소 | 7103 | 7104 | … |
    | --------- | --------- | ---- | --- |
    | 데이터 | 이름: x |
    | 값: @5002 | 이름: arr |
    | 값: @5006 | |
  - 객체 @5003의 변수 영역
    | 주소 | 8104 | 8105 | 8106 | … |
    | --------- | ------- | ---- | ---- | --- |
    | 데이터 | 이름: 0 |
    | 값: @5002 | 이름: 1 |
    | 값: @5004 | 이름: 2 |
    | 값: @5005 | |

<aside>
💡 **참조 카운트, 가비지 컬렉터(GC)**
**참조 카운트**
: 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 함
**가비지 컬렉터(GC)**
: 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화상태에 임박할 때마다 자동으로 수거 대상들을 수거(Collecting)합니다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈공간이 됩니다.

</aside>

### 4-3. 변수 복사 비교

- 변수 복사

  ```jsx
  var a = 10;
  var b = a;

  var obj1 = {
    c: 10,
    d: 'ddd',
  };
  var obj2 = obj1;
  ```

  - 데이터 할당의 흐름
    1. 기본형 데이터 변수 선언 및 할당 1: 변수 영역의 빈 공간(@1001)을 확보하고, 그 주소의 이름을 `a`라고 지정한다.
    2. 기본형 데이터 변수 선언 및 할당 2: 숫자 10을 검색하고 없으므로 빈 공간(@5001)에 저장하고, 이 주소를 @1001에 넣는다.
    3. 기본형 데이터 변수 복사 1: 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 `b`라고 지정한다.
    4. 기본형 데이터 변수 복사 2: 식별자 `a`를 검색하여 @1001에 저장된 값인 메모리 주소값인 @5001을 @1002 값에 저장한다.
    5. 참조형 데이터 변수 선언 및 할당 1: 변수 영역의 빈 공간(@1003)을 확보하고 식별자 `obj1`로 지정한다.
    6. 참조형 데이터 변수 선언 및 할당 2: 데이터 영역의 빈 공간 @5002를 확보하고, 데이터 그룹이 담기기 위한 별도의 변수 영역 @7103 ~ @7104를 확보하여 그 주소를 @5002의 값으로 저장한다.
    7. 참조형 데이터 변수 선언 및 할당 3: @7103에는 식별자 `c`를, @7104에는 식별자 `d`를 지정한다.
    8. 참조형 데이터 변수 선언 및 할당 4: `c`에 들어갈 데이터 숫자 10을 검색하여 데이터가 저장된 주소 @5001을 찾아 @7103의 값으로 저장한다.
    9. 참조형 데이터 변수 선언 및 할당 5: `d`에 들어갈 데이터 문자열 ‘ddd’를 검색한다. 검색 결과 없으므로 임의로 @5003에 저장하고, 이 주소를 @7104에 저장한다.
    10. 참조형 데이터 변수 복사 1: 변수 영역의 빈 공간(@1004)를 확보하고, 식별자 `obj2`로 지정한다.
    11. 참조형 데이터 변수 복사 2: 식별자 `obj1`을 검색(@1003)해 저장된 값 @5002을 @1004에 저장한다.
        {' '}
        <aside>
          💡 **Point!** 변수 복사: 기본형 데이터 vs. 참조형 데이터 **같은 점**: 같은 주소를 바라보게
          된다.(@1001과 @1002는 모두 값이 @5001, @1003과 @1004에는 모든 값이 @5002 ) **다른 점**:
          복사 과정은 동일하지만 데이터 할당 과정에서 별도의 변수 영역을 설정한다는 점에서 이미
          차이가 발생.
        </aside>
  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | … |
    | --------- | ---------- | ---- | ---- | ---- | --- |
    | 데이터 | 이름; a |
    | 값: @5001 | 이름; b |
    | 값: @5001 | 이름; obj1 |
    | 값: @5002 | 이름; obj2 |
    | 값: @5002 | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | … |
    | ------ | ---- | ------------- | ----- | ---- | --- |
    | 데이터 | 10 | @7103 ~ @7104 | ‘ddd’ | | |
  - 객체 @5002의 변수 영역
    | 주소 | 7103 | 7104 | … |
    | --------- | ------- | ---- | --- |
    | 데이터 | 이름: c |
    | 값: @5001 | 이름: d |
    | 값: @5003 | |

- 변수 복사 이후 값 변경 결과 비교 1 - 객체의 프로퍼티 변경 시

  ```jsx
  var a = 10;
  var b = a;
  var obj1 = { c: 10, d: 'ddd' };
  var obj2 = obj1;

  // 아래의 코드부터 해석합니다.
  b = 15;
  obj2.c = 20;
  ```

  - 데이터 할당의 흐름

    1. 데이터 영역에 숫자 15가 있는지 검색한다. 검색 결과 없으므로 데이터 영역 내에서 새로운 공간 @**5004**에 숫자 15을 저장한다.
    2. 숫자 15가 위치한 데이터 영역의 주소(@**5004**)를 변수 영역에서 식별자 `b`의 값으로 저장한다.
    3. 데이터 영역에 숫자 20이 있는지 검색한다. 검색 결과 없으므로 데이터 영역 내에서 새로운 공간 @**5005**에 숫자 20을 저장한다.
    4. 숫자 20이 위치한 데이터 영역의 주소(@**5005**)를 기억한다.
    5. 변수 영역에서 `obj2`를 식별자로 가진 주소(@1004)를 찾는다. 해당 식별자의 값인 주소 @5002로 이동한다.
    6. `obj2` 객체의 변수 영역에서 프로퍼티 `c`를 검색한다. 검색 결과 `c`의 주소(@7103)를 찾고, 이 곳에 값으로 숫자 20이 위치한 데이터 영역의 주소 @**5005**를 대입한다.
       {' '}
       <aside>
         💡 **Point!** 변수 복사: 기본형 데이터 vs. 참조형 데이터 1 - 기본형 데이터를 복사한 변수
         `b`의 값(데이터)을 변경(숫자형 → 숫자형)하였더니 @1002의 값(데이터 주소)이 달라짐 - 참조형
         데이터의 객체 내 프로퍼티 `c`의 값(데이터)을 변경(숫자형 → 숫자형)하였으나 @1003과 @1004의
         값(데이터 주소)에 변화는 나타나지 않음 (객체 @5002의 변수 영역에서는 주소값이 @5001 →
         @5005로 변경됨) 위 결과를 코드로 표현하면 아래와 같다.
       </aside>

    ````jsx
    a !== b; // a와 b는 (값이)다르다. obj1 === obj2 // obj1과 obj2는 서로 (값과 타입 모두)같다.
    ```
    <aside>
      💡 **Point!** 변수 복사: 기본형 데이터 vs. 참조형 데이터 2 **“기본형은 값을 복사하고 참조형은
      주소값을 복사한다”**는 표현은 사실, - 기본형은 주소값을 복사하는 과정이 **변수 영역에서
      1번**만 일어난다. - 참조형은 주소값을 복사하는 과정이 **객체의 변수 영역에서 1번** 일어나고,
      변수 영역에서는 기존 객체의 변수 영역 주소를 그대로 가져오기 때문에 변수 영역의 관점에서는
      주소값이 변하지 않는 것과 같이 보인다.
    </aside>

    ````

  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | … |
    | --------- | ---------- | ---- | ---- | ---- | --- |
    | 데이터 | 이름; a |
    | 값: @5001 | 이름; b |
    | 값: @5004 | 이름; obj1 |
    | 값: @5002 | 이름; obj2 |
    | 값: @5002 | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | … |
    | ------ | ---- | ------------- | ----- | ---- | ---- | --- |
    | 데이터 | 10 | @7103 ~ @7104 | ‘ddd’ | 15 | 20 | |
  - 객체 @5002의 변수 영역
    | 주소 | 7103 | 7104 | … |
    | --------- | ------- | ---- | --- |
    | 데이터 | 이름: c |
    | 값: @5005 | 이름: d |
    | 값: @5003 | |

- 변수 복사 이후 값 변경 결과 비교 2 - 객체 자체를 변경 시

  ```jsx
  var a = 10;
  var b = a;
  var obj1 = { c: 10, d: 'ddd' };
  var obj2 = obj1;

  b = 15;
  // 아래의 코드부터 해석합니다.
  obj2 = { c: 20, d: 'ddd' };
  ```

  - 데이터 할당의 흐름
    1. 데이터 영역에 숫자 20이 있는지 검색한다. 검색 결과 없으므로, @**5005**에 숫자 20을 저장한다.
    2. 숫자 20이 위치한 데이터 영역의 주소(@**5005**)를 기억한다.
    3. 데이터 영역에 문자열 ‘ddd’가 있는지 검색한다. 검색 결과 @**5003**에 있으므로 데이터 영역의 주소 @**5003**를 기억한다.
    4. 객체 자체에 대한 재할당에 해당하므로 새로운 데이터 영역 @**5006**을 선택하고, 그 안에 @**8204**, @**8205** 변수 영역을 생성한다.
    5. @**8204**를 식별자 `c`로 지정하고, 그 안에 데이터 영역의 숫자 20이 저장된 주소 @**5005**를 값으로 저장한다.
    6. @**8205**를 식별자 `d`로 지정하고, 그 안에 데이터 영역의 문자열 ‘ddd’이 저장된 주소 @**5003**을 값으로 저장한다.
    7. 새로운 객체 @**5006**를 변수 영역 내 식별자 `obj2`에 값으로 저장한다.
    8. 기존의 객체 @**5002**는 참조 카운트가 0이므로 GC 대상이 되어 사라진다.
       {' '}
       <aside>
         💡 **Point! 가변**의 성립 조건 참조형 데이터가 “가변값”이라고 설명할 때의 “**가변**”은
         참조형 데이터 자체를 변경하는 경우(새로운 객체의 할당)가 아니라, 그 **내부 프로퍼티를
         변경할 때만 성립한다**.
       </aside>
  - 변수 영역
    | 주소 | 1001 | 1002 | 1003 | 1004 | … |
    | --------- | ---------- | ---- | ---- | ---- | --- |
    | 데이터 | 이름; a |
    | 값: @5001 | 이름; b |
    | 값: @5004 | 이름; obj1 |
    | 값: @5002 | 이름; obj2 |
    | 값: @5002 | |
  - 데이터 영역
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | … |
    | ------ | ---- | ------------- | ----- | ---- | ---- | ------------- | --- |
    | 데이터 | 10 | @7103 ~ @7104 | ‘ddd’ | 15 | 20 | @8204 ~ @8205 | |
  - 객체 @5002의 변수 영역
    | 주소 | 7103 | 7104 | … |
    | --------- | ------- | ---- | --- |
    | 데이터 | 이름: c |
    | 값: @5005 | 이름: d |
    | 값: @5003 | |
  - 객체 @5002의 변수 영역
    | 주소 | 8204 | 8205 | … |
    | --------- | ------- | ---- | --- |
    | 데이터 | 이름: c |
    | 값: @5005 | 이름: d |
    | 값: @5003 | |

---

## 5. 불변 객체 (Immutable Object)

### 5-1. 불변 객체를 만드는 간단한 방법

- 불변 객체의 중요성

  - 최근 React, Vue.js, Angular 등의 라이브러리나 프레임워크에서 뿐만 아니라 함수형 프로그래밍, 디자인 패턴 등에서도 매우 중요한 기초가 되는 개념이다.
  - 앞서 살펴본 바와 같이, 참조형 데이터의 **가변**은 내부 프로퍼티를 변경하는 경우에만 성립한다.
  - 따라서 기본형 데이터와 같이 데이터 자체를 변경하는 경우(새로운 데이터를 할당하는 경우) 기존 데이터는 변하지 않게 된다(불변이다).

  → 그렇다면 내부 프로퍼티를 변경하고자 할 때마다 매번 새로운 객체를 만들어 재할당을 하면 되지 않을까?

- 불변 객체가 필요한 상황
  - 값으로 전달 받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우 사용된다.
- 객체의 가변성에 따른 문제점 (객체의 가변성으로 인한 문제점을 가진 경우)

  ```jsx
  // ex. 1-10
  // Step 1. user 객체 생성
  var user = {
    name: 'James',
    gender: 'male',
  };

  // changeName 함수 생성
  var changeName = function (user, newName) {
    var newUser = user;
    newUser.name = newName;
    return newUser;
  };

  // Stem 2. user2 변수 생성 및 user 객체의 name 프로퍼티를 'Tom'으로 바꾸는 함수 changeName()을 호출하여 그 결과를 user2에 저장
  var user2 = changeName(user, 'Tom');

  if (user !== user2) {
    console.log('유저 정보가 변경되었습니다.');
  }
  console.log(user.name, user2.name); // Tom Tom
  console.log(user === user2); // true
  ```

  - Step 1 user 객체 생성
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | 1004 | … |
      | --------- | ---- | ---------- | ---- | ---- | --- |
      | 데이터 | | 이름; user |
      | 값: @5002 | | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | … |
      | ------ | ----- | ------------- | ---- | ---- | --- |
      | 데이터 | James | @7101 ~ @7102 | male | | |
    - 객체 @5002의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: gender |
      | 값: @5003 | |
  - Step 2 user 객체의 name 프로퍼티를 'Tom'으로 바꾸는 함수 `changeName()`을 호출하여 그 결과를 user2에 저장
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | 1004 | … |
      | --------- | ----------- | ---------- | ---- | ---- | --- |
      | 데이터 | | 이름; user |
      | 값: @5002 | 이름: user2 |
      | 값: @5002 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | … |
      | ------ | ----- | ------------- | ---- | ---- | --- |
      | 데이터 | James | @7101 ~ @7102 | male | Tom | |
    - 객체 @5002의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5004 | 이름: gender |
      | 값: @5003 | |

- 객체의 가변성에 따른 문제점의 해결 방법 1 (changeName 함수가 새로운 객체를 반환하도록 수정함)

  ```jsx
  // ex. 1-11
  // Step 1. user 객체 생성
  var user = {
    name: 'James',
    gender: 'male',
  };

  // changeName 함수 생성
  var changeName = function (user, newName) {
    return {
      name: newName,
      gender: user.gender,
    };
  };

  // Stem 2. user2 변수 생성 및 새로운 객체 생성
  var user2 = changeName(user, 'Tom');

  if (user !== user2) {
    console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.
  }

  console.log(user.name, user2.name); // James Tom
  console.log(user === user2); // false
  ```

  - Step 1 user 객체 생성
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | 1004 | … |
      | --------- | ---- | ---------- | ---- | ---- | --- |
      | 데이터 | | 이름; user |
      | 값: @5002 | | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | … |
      | ------ | ----- | ------------- | ---- | ---- | --- |
      | 데이터 | James | @7101 ~ @7102 | male | | |
    - 객체 @5002의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: gender |
      | 값: @5003 | |
  - Step 2 user2 변수 생성 및 새로운 객체 생성
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | 1004 | … |
      | --------- | ----------- | ---------- | ---- | ---- | --- |
      | 데이터 | | 이름; user |
      | 값: @5002 | 이름: user2 |
      | 값: @5005 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | … |
      | ------ | ----- | ------------- | ---- | ---- | ------------- | --- |
      | 데이터 | James | @7101 ~ @7102 | male | Tom | @8204 ~ @8205 | |
    - 객체 @5002의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: gender |
      | 값: @5003 | |
    - 객체 @5005의 변수 영역
      | 주소 | 8204 | 8205 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5004 | 이름: gender |
      | 값: @5003 | |

- 객체의 가변성에 따른 문제점의 해결 방법 2 (대상 객체의 프로퍼티 개수에 상관 없이 모든 프로퍼티를 복사하는 함수 생성)

  ```jsx
  // ex. 1-12
  // 기존 정보(target)를 복사해서 새로운 객체(result)를 반환하는 함수(얕은 복사)
  var copyObject = function (target /* 기존 객체 */) {
    var result = {}; // 새로운 객체 생성
    for (var prop in target) {
      // prop => 기존 객체의 key값
      result[prop] = target[prop]; // 기존 객체의 value를 새로운 객체의 key에 새로운 value에 할당
    }
    return result; // 새로운 객체 변환
  };

  // ex. 1-13
  var user = {
    name: 'James',
    gender: 'male',
  };

  var user2 = copyObject(user); // Step 1 user 정보를 복사하여 새로운 user2 객체 생성 및 붙여넣기
  user2.name = 'Tom'; // Step 2 user2 객체의 name 프로퍼티 key의 값을 'Tom'으로 변경

  if (user !== user2) {
    console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.
  }
  console.log(user.name, user2.name); // James Tom
  console.log(user === user2); // false
  ```

  - Step 1 user 정보를 복사하여 새로운 user2 객체 생성 및 붙여넣기
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | 1004 | … |
      | --------- | ----------- | ---------- | ---- | ---- | --- |
      | 데이터 | | 이름; user |
      | 값: @5002 | 이름: user2 |
      | 값: @5004 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | … |
      | ------ | ----- | ------- | ---- | ---- | --- |
      | 데이터 | James | @7101 ~ |
      | @7102 | male | @8203 ~ |
      | @8204 | |
    - 객체 @5002의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: gender |
      | 값: @5003 | |
    - 객체 @5004의 변수 영역
      | 주소 | 8203 | 8204 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: gender |
      | 값: @5003 | |
  - Step 2 user2 객체의 name 프로퍼티 key의 값을 'Tom'으로 변경
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | 1004 | … |
      | --------- | ----------- | ---------- | ---- | ---- | --- |
      | 데이터 | | 이름; user |
      | 값: @5002 | 이름: user2 |
      | 값: @5004 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | |
      | ------ | ----- | ------- | ---- | ---- | ---- | --- |
      | 데이터 | James | @7101 ~ |
      | @7102 | male | @8203 ~ |
      | @8204 | Tom | |
    - 객체 @5002의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: gender |
      | 값: @5003 | |
    - 객체 @5004의 변수 영역
      | 주소 | 8203 | 8204 | … |
      | --------- | ------------ | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5005 | 이름: gender |
      | 값: @5003 | |
      결론: (Step 1) user 객체를 user2에 재할당하여 새로 생성(@5004 생성) ⇒ user 객체는 불변 객체가 되었다

### 5-2 얕은 복사와 깊은 복사

- 얕은 복사(shallow copy) : 객체의 변수영역에 저장된 데이터(프로퍼티 key - value)를 그대로 복사하여 새로 생성한 객체 변수영역에 그대로 저장하는 복사 방법 (⇒ See ex. 1-12)
- 깊은 복사(deep copy) : 객체의 변수영역에 저장된 데이터(프로퍼티 key - value)를 복사하여 프로퍼티 key의 value(데이터 영역에서의 데이터가 저장된 주소값, @50XX)를 새롭게 생성하는 복사 방법
- 중첩된 객체에 대한 얕은 복사

  ```jsx
  // ex. 1-14
  var copyObject = function (target /* 기존 객체 */) {
    var result = {}; // 새로운 객체 생성
    for (var prop in target) {
      // prop => 기존 객체의 key값
      result[prop] = target[prop]; // 기존 객체의 value를 새로운 객체의 key에 새로운 value에 할당
    }
    return result; // 새로운 객체 변환
  };

  // Step 1. user 객체 생성
  var user = {
    name: 'James',
    urls: {
      portfolio: 'http://github.com/abc',
      blog: 'http://blog.naver.com/abc',
      facebook: 'http://facebook.com/abc',
    },
  };

  // Step 2. copyObject 함수를 이용하여 기존 user 객체를 새로 생성한 user2 객체에 재할당
  var user2 = copyObject(user);

  // Step 3. user2의 name 프로퍼티 값을 Tom으로 변경
  user2.name = 'Tom';
  console.log(user.name === user2.name); // false

  // Step 4. user의 프로퍼티 key인 urls 객체 안에 있는 프로퍼티 key값 portfolio의 value를 'http://portfolio.com'으로 변경 시도
  user.urls.portfolio = 'http://portfolio.com';
  console.log(user.urls.portfolio === user2.urls.portfolio); // true

  // Step 5. user2의 프로퍼티 key인 urls 객체 안에 있는 프로퍼티 key값 blog의 value를 ''으로 변경 시도
  user2.urls.blog = '';
  console.log(user.urls.blog === user2.urls.blog); // true
  ```

  - Step 1 user 객체 생성
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | … |
      | --------- | ---------- | ---- | ---- | --- |
      | 데이터 | 이름: user |
      | 값: @5004 |
      | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | … |
      | ------ | ----- | ----------------------- | --------------------------- | ------------- | ------------------------- | --- |
      | 데이터 | James | 'http://github.com/abc' | 'http://blog.naver.com/abc' | @7101 ~ @7102 | 'http://facebook.com/abc' | |
    - 객체 @5004의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: urls |
      | 값: @3011 ~ @3013 | |
    - 객체 @7102의 변수 영역
      | 주소 | 3011 | 3012 | 3013 | … |
      | --------- | --------------- | ---- | ---- | --- |
      | 데이터 | 이름: portfolio |
      | 값: @5002 | 이름: blog |
      | 값: @5003 | 이름: facebook |
      | 값: @5005 | |
  - Step 2 copyObject 함수를 이용하여 기존 user 객체를 새로 생성한 user2 객체에 재할당
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | … |
      | --------- | ----------- | ---- | ---- | --- |
      | 데이터 | 이름: user |
      | 값: @5004 | 이름: user2 |
      | 값: @5007 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | 5007 | 5008 | … |
      | ------ | ----- | ----------------------- | --------------------------- | ------------- | ------------------------- | ---- | ------------- | ---- | --- |
      | 데이터 | James | 'http://github.com/abc' | 'http://blog.naver.com/abc' | @7101 ~ @7102 | 'http://facebook.com/abc' | | @8204 ~ @8205 | | |
    - 객체 @5004의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: urls |
      | 값: @3011 ~ @3013 | |
    - 객체 @7102의 변수 영역
      | 주소 | 3011 | 3012 | 3013 | … |
      | --------- | --------------- | ---- | ---- | --- |
      | 데이터 | 이름: portfolio |
      | 값: @5002 | 이름: blog |
      | 값: @5003 | 이름: facebook |
      | 값: @5005 | |
    - 객체 @5007의 변수 영역
      | 주소 | 8204 | 8205 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: urls |
      | 값: @3011 ~ @3013 | |
  - Step 3 user2의 name 프로퍼티 값을 Tom으로 변경
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | … |
      | --------- | ----------- | ---- | ---- | --- |
      | 데이터 | 이름: user |
      | 값: @5004 | 이름: user2 |
      | 값: @5007 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | 5007 | 5008 | … |
      | :------: | :-----: | :-----------------------: | :---------------------------: | :-------------: | :-------------------------: | :----: | :-------------: | :----: | :---: |
      | 데이터 | James | 'http://github.com/abc' | 'http://blog.naver.com/abc' | @7101 ~ @7102 | 'http://facebook.com/abc' | | @8204 ~ @8205 | Tom | |
    - 객체 @5004의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: urls |
      | 값: @3011 ~ @3013 | |
    - 객체 @7102의 변수 영역
      | 주소 | 3011 | 3012 | 3013 | … |
      | --------- | --------------- | ---- | ---- | --- |
      | 데이터 | 이름: portfolio |
      | 값: @5002 | 이름: blog |
      | 값: @5003 | 이름: facebook |
      | 값: @5005 | |
    - 객체 @5007의 변수 영역
      | 주소 | 8204 | 8205 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5008 | 이름: urls |
      | 값: @3011 ~ @3013 | |
  - Step 4 user의 프로퍼티 key인 urls 객체 안에 있는 프로퍼티 key값 portfolio의 value를 'http://portfolio.com'으로 변경 시도
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | … |
      | --------- | ----------- | ---- | ---- | --- |
      | 데이터 | 이름: user |
      | 값: @5004 | 이름: user2 |
      | 값: @5007 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | 5007 | 5008 | 5009 | … |
      | ------ | ----- | ----------------------- | --------------------------- | ------------- | ------------------------- | ---- | ------------- | ---- | ---------------------- | --- |
      | 데이터 | James | 'http://github.com/abc' | 'http://blog.naver.com/abc' | @7101 ~ @7102 | 'http://facebook.com/abc' | | @8204 ~ @8205 | Tom | 'http://portfolio.com' | |
    - 객체 @5004의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: urls |
      | 값: @3011 ~ @3013 | |
    - 객체 @7102의 변수 영역
      | 주소 | 3011 | 3012 | 3013 | … |
      | --------- | --------------- | ---- | ---- | --- |
      | 데이터 | 이름: portfolio |
      | 값: @5009 | 이름: blog |
      | 값: @5003 | 이름: facebook |
      | 값: @5005 | |
    - 객체 @5007의 변수 영역
      | 주소 | 8204 | 8205 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5008 | 이름: urls |
      | 값: @3011 ~ @3013 | |
  - Step 5 user2의 프로퍼티 key인 urls 객체 안에 있는 프로퍼티 key값 blog의 value를 ''으로 변경 시도
    - 변수 영역
      | 주소 | 1001 | 1002 | 1003 | … |
      | --------- | ----------- | ---- | ---- | --- |
      | 데이터 | 이름: user |
      | 값: @5004 | 이름: user2 |
      | 값: @5007 | | |
    - 데이터 영역
      | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | 5007 | 5008 | 5009 | 5010 | … |
      | ------ | ----- | ----------------------- | --------------------------- | ------------- | ------------------------- | ---- | ------------- | ---- | ---------------------- | ---- | --- |
      | 데이터 | James | 'http://github.com/abc' | 'http://blog.naver.com/abc' | @7101 ~ @7102 | 'http://facebook.com/abc' | | @8204 ~ @8205 | Tom | 'http://portfolio.com' | '' | |
    - 객체 @5004의 변수 영역
      | 주소 | 7101 | 7102 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5001 | 이름: urls |
      | 값: @3011 ~ @3013 | |
    - 객체 @7102의 변수 영역
      | 주소 | 3011 | 3012 | 3013 | … |
      | --------- | --------------- | ---- | ---- | --- |
      | 데이터 | 이름: portfolio |
      | 값: @5009 | 이름: blog |
      | 값: @5010 | 이름: facebook |
      | 값: @5005 | |
    - 객체 @5007의 변수 영역
      | 주소 | 8204 | 8205 | … |
      | ----------------- | ---------- | ---- | --- |
      | 데이터 | 이름: name |
      | 값: @5008 | 이름: urls |
      | 값: @3011 ~ @3013 | |
      **[ 결과 ]**

  ```jsx
  // user.name vs. user2.name
  console.log([user.name](http://user.name)); // James // @5004>@7101>@5001
  console.log(user2.name); // Tom // @5007>@8204>@5008
  console.log(user.name === user2.name); // false

  // user.urls vs. user2.urls
  console.log([user.](http://user.name)urls); // @5004>@7102>@3011 ~ @3013>@5009,@5010,@5005
  /*
  	{
  		portfolio: 'http://portfolio.com',
  		blog: '',
  		facebook: 'http://facebook.com/abc'
  	}
  */
  console.log(user2.urls); // @5007>@8205>@3011 ~ @3013>@5009,@5010,@5005
  /*
  	{
  		portfolio: 'http://portfolio.com',
  		blog: '',
  		facebook: 'http://facebook.com/abc'
  	}
  */
  console.log(user.urls === user2.urls); // true

  // user.urls.portfolio vs. user2.urls.portfolio
  console.log([user.](http://user.name)urls.portfolio); // 'http://portfolio.com' // @5004>@7102>@3011>@5009
  console.log([user2.](http://user.name)urls.portfolio); // 'http://portfolio.com' // @5007>@8205>@3011>@5009
  console.log(user.urls.portfolio === user2[.](http://user.name)urls.portfolio); // true

  // user.urls.blog vs. user2.urls.blog
  console.log([user.](http://user.name)urls.blog); // '' // @5004>@7102>@3012>@5010
  console.log([user2.](http://user.name)urls.blog); // '' // @5007>@8205>@3012>@5010
  console.log(user.urls.blog === user2[.](http://user.name)urls.blog); // true

  // user.urls.facebook vs. user2.urls.facebook
  console.log([user.](http://user.name)urls.portfolio); // 'http://facebook.com/abc' // @5004>@7102>@3013>@5005
  console.log([user2.](http://user.name)urls.portfolio); // 'http://facebook.com/abc' // @5007>@8205>@3013>@5005
  console.log(user.urls.portfolio === user2[.](http://user.name)urls.portfolio); // true
  ```

  **[ 결론 ]**
  user.name은 예제 1-12와 1-13에서 살펴본 바와 같이 얕은 복사를 통해 서로 다른 주소값을 가지고 있다. 따라서 user2의 name 프로퍼티 값을 바꾸어도 user의 name 프로퍼티 값은 변경되지 않는다.
  하지만, 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터(user.urls)와 동일한 주소값을 참조하고 있음을 확인할 수 있다. 따라서 user.urls.portfolio의 값과 user2.urls.blog의 값을 변경하면 user2.urls.portfolio와 user.urls.blog 값도 변경된다(사본의 변경이 원본을 변경시킨다).
  그러므로 user.urls 프로퍼티에 대해서도 불변 객체로 만들기 위해서는 깊은 복사(deep copy)를 진행하여야 한다.

- 중첩된 객체에 대한 깊은 복사

  ```jsx
  // ex. 1-15
  var user2 = copyObject(user);
  user2.urls = copyObject(user.urls);

  user.urls.portfolio = 'http://portfolio.com';
  // user.urls.portfolio vs user2.urls.portfolio
  console.log(user.urls.portfolio);
  /*
  	{
  		portfolio: 'http://github.com/abc',
  		blog: 'http://blog.naver.com/abc',
  		facebook: 'http://facebook.com/abc'
  	}
  */
  console.log(user2.urls.portfolio);
  /*
  	{
  		portfolio: 'http://portfolio.com',
  		blog: 'http://blog.naver.com/abc',
  		facebook: 'http://facebook.com/abc'
  	}
  */
  console.log(user.urls.portfolio === user2.urls.portfolio); // false

  user2.urls.blog = '';
  console.log(user.urls.blog);
  /*
  	{
  		portfolio: 'http://github.com/abc',
  		blog: 'http://blog.naver.com/abc',
  		facebook: 'http://facebook.com/abc'
  	}
  */
  console.log(user2.urls.blog);
  /*
  	{
  		portfolio: 'http://portfolio.com',
  		blog: '',
  		facebook: 'http://facebook.com/abc'
  	}
  */
  console.log(user.urls.blog === user2.urls.blog); // false
  ```

  위 예제를 통해 살펴본 바와 같이, 객체를 복사하여 객체 내부의 모든 값을 완전히 새로운 데이터로 만들고자 하는 경우

  - 객체 프로퍼티의 값이 기본형 데이터인 경우: 그대로 복사
  - 객체 프로퍼티의 값이 참조형 데이터인 경우: 한번 더 내부 프로퍼티들을 복사
    따라서, 중첩된 객체에 대한 깊은 복사가 이루어짐에도 불구하고 이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행해야 된다는 점에서 개선할 여지가 있다.

- 객체의 깊은 복사를 수행하는 범용 함수
  ```jsx
  // ex. 1-16
  var copyObjectDeep = function (target /* 복사하고자 하는 기존 값(또는 객체)*/) {
    var result = {}; // 새로운 객체 생성
    if (typeof target === 'object' && target !== null) {
      // 복사하고자 하는 기존 객체(target)의 타입과 데이터 보유 여부를 확인
      for (var prop in target) {
        // 복사하고자 하는 기존 객체(target)의 내부 프로퍼티 key를 순회하는 for문
        result[prop] = copyObjectDeep(target[prop]); // 복사하고자 하는 기존 객체(target)의 프로퍼티 key - value를 새로 생성한 객체에 프로퍼티 key - value로 할당 (함수를 재귀적으로 호출하였다)
      }
    } else {
      // 복사하고자 하는 값(target)이 객체가 아닌 경우
      result = target; // 기본형 데이터(원시값 또는 불변값)에 대한 재할당을 수행
    }
    return result; // 복사된 새로운 값(또는 객체)를 반환
  };
  ```
  `copyObjectDeep()`함수를 사용하여 객체를 복사한 다음에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 된다.
  따라서 어느 한 쪽의 프로퍼티를 변경하여도 다른 쪽에 영향을 주지 않게 되었다(즉 원본과 사본 모두 불변하는 객체가 되었다).
- 깊은 복사 결과 확인

  ```jsx
  // ex. 1-17
  var obj = {
    a: 1,
    b: {
      c: null,
      d: [1, 2],
    },
  };

  var obj2 = copyObjectDeep(obj);

  obj2.a = 3;
  obj2.b.c = 4;
  obj.b.d[1] = 3;

  console.log(obj);
  /*
  {
  	a: 1,
  	b: {
  			c: null,
  			d: [1, 3]
  	}
  }
  */
  console.log(obj2);
  /*
  {
  	a: 3,
  	b: {
  			c: 4,
  			d: { '0': 1, '1': 2 }
  	}
  }
  */
  ```

- JSON을 활용한 간단한 깊은 복사
  : 객체를 JSON 문법으로 표현된 문자열로 전환한 뒤, 다시 JSON 객체로 변경하는 방식이다. 따라서 이 방식은 httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법이다.

  ```jsx
  // ex. 1-18
  var copyObjectViaJSON = function (target) {
    return JSON.parse(JSON.stringify(target));
  };

  // JSON.parse(): JSON문자열을 자바스크립트 객체로 변환합니다.
  // 새로운 객체 <= JSON 문자열

  // JSON.stringify() : 자바스크립트 객체를 JSON문자열로 변환합니다.
  // 기존 객체 => JSON 문자열

  var obj = {
    a: 1,
    b: {
      c: null,
      d: [1, 2],
      func1: function () {
        console.log(3);
      },
    },
    func2: function () {
      console.log(4);
    },
  };

  var obj2 = copyObjectViaJSON(obj);

  obj2.a = 3;
  obj2.b.c = 4;
  obj.b.d[1] = 3;

  console.log(obj);
  /*
  {
    a: 1,
    b: {
  		  c: null,
  			d: [ 1, 3 ], 
  			func1: [Function: func1] 
  	},
    func2: [Function: func2]
  }
  */
  console.log(obj2);
  /*
  { 
  	a: 3, 
  	b: { 
  			c: 4, 
  			d: [ 1, 2 ] 
  	} 
  }
  */
  ```

---

## 6. `undefined`와 `null`

- 자바스크립트에 “없음”을 나타내는 값 ⇒ (1) `undefined` , (2) `null`

<aside>
💡 `undefined`는 (1)사용자가 명시적으로 지정하거나(즉 사용자의 의도에 의해 할당된 경우) (2)자바스크립트 엔진이 자동으로 부여하는 경우로 나뉜다. 여기서는 자바스크립트 엔진에 의하여 부여된 `undefined`에 대해서만 살피도록 한다.

</aside>

- 자동으로 `undefined` 를 부여하는 경우

  ```jsx
  // ex. 1-19
  var a;
  console.log(a); // (1) undefined, 값을 대입하지 않은 변수에 접근 (즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때)

  var obj = { a: 1 };
  console.log(obj.a); // 1
  console.log(obj.b); // (2) 객체 내부의 존재하지 않는 프로퍼티에 접근
  console.log(b); // ReferenceError: b is not defined

  var func = function () {};
  var c = func();
  console.log(c); // undefined // return 문이 없는 함수의 호출
  ```

- `undefined`와 배열

  ```jsx
  // ex. 1-20
  var arr1 = [];
  arr1.length = 3;
  console.log(arr1); // [ <3 empty items> ] // undefined도 할당되어 있지 않다

  var arr2 = new Array(3);
  console.log(arr2); // [ <3 empty items> ] // undefined도 할당되어 있지 않다

  var arr3 = [undefined, undefined, undefined];
  console.log(arr3); // [undefined, undefined, undefined]
  ```

- 빈 요소와 배열의 순회
  {' '}
  <aside>
    💡 비어있는 요소(empty)와 `undefined`를 할당한 요소의 순회 → “비어있는 요소”는 순회와 관련된
    배열 메서드(`forEach()`, `map()`, `filter()`, `reduce()` 등)들의 순회 대상에서 제외됨
  </aside>
  ```jsx // ex. 1-21 var arr1 = [undefined, 1]; var arr2 = []; arr2[1] = 1; // arr2 = [empty, 1] arr1.forEach((v,
  i) => console.log(v, i)); /* undefined 0 1 1 */ arr2.forEach((v, i) => console.log(v, i)); /* 1 1 */
  console.log(arr1.map((v, i) => v + i)); // [NaN, 2] console.log(arr2.map((v, i) => v + i)); // [empty,
  2] console.log(arr1.filter((v, i) => !v)); // [undefined] console.log(arr2.filter((v, i) => !v)); //
  [] console.log(arr1.reduce((p, c, i) => p + c + i, '')); // undefined011 console.log(arr2.reduce((p,
  c, i) => p + c + i, '')); // 11 ``` - `undefined`를 할당한 arr1에 대해서는 각각의 메서드들이 직접 요소를
  순회하여 결과를 출력한다. 하지만, 빈 요소가 포함된 arr2에 대해서는 각 메서드들이 빈 요소에 대해서는
  어떠한 처리도 하지 않고 건너뛰었음을 결과를 통해 확인할 수 있다. ⇒ 이러한 일이 가능한 이유는 배열이
  사실은 **“객체”**이기 때문이다.
- 사용자가 명시적으로 부여한 `undefined` vs 자바스크립트 엔진에 의해 비어있는 요소에 접근 시 반환되는 `undefined`

  - 사용자가 명시적으로 부여한 `undefined`
    ⇒ 그 자체로 값으로서 역할을 수행함
    ⇒ 이 때의 `undefined`는 프로퍼티나 배열의 요소로서 고유의 key값이 실제로 존재하게 된다.
    ⇒ 따라서 순회의 대상이 된다.
  - 자바스크립트 엔진에 의해 비어있는 요소에 접근 시 반환되는 `undefined`
    ⇒ 해당 프로퍼티 또는 배열의 key값인 인덱스 자체가 존재하지 않음
    ⇒ 실제로 비어있어서 어쩔 수 없이 자바스크립트 엔진이 반환해준 `undefined`는 문자 그대로, **literally! “값이 없음”**을 나태난다.

  {' '}

  <aside>
    💡 예제 1-19의 [1]의 “값을 대입하지 않은 변수”, 즉 데이터 영역의 메모리 주소를 지정하지 않은
    식별자에는 자바스크립트가 직접 `undefined`를 할당한다. TC39의 ECMAScript 명세서에서는 다음과
    같이 설명한다. **”`var` 변수는 environmentRecord가 인스턴스화될 때 생성되면서 `undefined`로
    초기화됩니다.”** 한편 ES6에서 등장한 `let`, `const`에 대해서는 `undefined`를 할당하지 않은 채로
    초기화를 마치며, 이후 실제 변수가 평가되기 전까지는 해당 변수에 접근할 수 없습니다(**Temporal
    Dead Zone**). 명세서에서는 다음과 같이 설명한다. **”`let`과 `const` 변수는 environmentRecord가
    인스턴스화될 때 생성되지만 실제 변수가 평가되기 전까지는 접근할 수 없습니다.”**
  </aside>
  **[결론]** - 두 가지 `undefined`에 대해 혼동스럽기 때문에 두 가지 중 하나를 사용하지 않으면 된다. -
  따라서 자바스크립트 엔진이 반환하는 `undefined`에 대해서는 통제가 불가능하기 때문에 통제할 수 있는
  “사용자가 명시적으로 `undefined`를 부여하는 경우”를 사용하지 않으면 된다. - 하지만 실제로 값이 비어있음을
  명시하여야 하는 경우가 있을 수 있다. - 이럴 때를 위하여 `null`을 사용한다. (`**null` 사용 권고사항**)

- `undefined`와 `null`의 비교

  ```jsx
  // ex. 1-22
  var n = null;
  console.log(typeof n); // object => 이것은 자바스크립트 자체 버그이다.

  // 동등 연산자(equility operator) "=="를 이용한 비교
  console.log(n == undefined); // true
  console.log(n == null); // true

  // 일치 연산자(identity operator) "==="를 이용한 비교
  console.log(n === undefined); // false
  console.log(n === null); // true => 일치 연산자를 사용하여야 해당 변수에 null이 할당되었는지 명확히 판단할 수 있다.
  ```

---

## 7. 정리

- **1-1 데이터 타입의 종류**
  자바스크립트 데이터 타입에는 크게 기본형과 참조형이 있다. 기본적으로 기본형은 불변값이고 참조형은 가변값이다.
- **1-2 데이터 타입에 관한 배경지식**
  **변수:** 변경 가능한 데이터가 담길 수 있는 공간
  **식별자**: 변수의 이름
- **1-3 변수 선언과 데이터 할당**
  (Step 1) 변수 선언
  (Step 2) 컴퓨터가 메모리의 빈 공간에 식별자를 저장
  (Step 3) 해당 메모리의 빈 공간에 자동으로 `undefined`할당
  (Step 4) 런타임으로 동작하며 해당 변수에 기본형 데이터를 할당하려는 경우 별도의 메모리 공간에 데이터를 저장
  (Step 5) 해당 별도의 메모리 공간의 주소를 변수의 값으로 할당
- **1-4 기본형 데이터와 참조형 데이터**
  참조형 데이터를 할당하고자 할 경우 컴퓨터는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보하여 확보된 주소를 변수에 연결하고, 다시 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장하고, 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭한다.
  이처럼 할당 과정에서 기본형과 차이가 생긴 이유는 참조형 데이터는 여러 개의 프로퍼티(변수)를 모은 “그룹”이기 때문이다. 그리고 이 차이로 인해 참조형 데이터를 “가변값”으로 여겨야만 하는 상황이 발생한다.
- **1-5 불변 객체**
  참조형 데이터를 가변값으로 여겨야 하는 상황임에도 이를 불변값으로 사용하는 방법이 없지는 않다.
  이 경우 내부 프로퍼티들을 일일이 복사하면 된다(깊은 복사).
  혹은 라이브러리를 사용하는 방법도 있다(ex. `JSON.parse(JSON.stringify())`).
  불변 객체는 최근 자바스크립트 진영에서 가장 중요한 개념 중 하나이다.
- **1-6 `undefined`와 `null`**
  “없음”을 나타내는 값은 `undefined`와 `null` , 이렇게 두 가지가 있다.
  `undefined`는 어떤 변수에 값이 존재하지 않을 경우를 의미하고, `null`은 사용자가 명시적으로 “없음”을 표현하기 위해 대입한 값이다.
  본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 `undefined`를 대입하는 것은 하지 않는게 좋다.
